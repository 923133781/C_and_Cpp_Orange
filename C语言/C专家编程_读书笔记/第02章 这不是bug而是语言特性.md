### 2.1 这关于特性何事

一个`L`的`NUL`和两个`L`的`NULL`

- NUL用于结束一个ACSII字符串
- NULL用于表示空指针



### 2.2 多做之处



const不是一个真正的常量，而switch语句的case要求是一个常量。所以以下代码会编译出错。

```cpp
    const int two=2;
    switch(i)
    {
        case 1:
            printf("case 1\n");
        case two:
            printf("case two");
    }
```

**名词fall through:意思就是如果case语句后面不加break，程序就会继续执行下去**
 一个忘了的知识点，->表示的是指向结构体成员。



ANSI C的一个特性是 **相邻的字符串常量将被自动合并成一个字符串**

```C
printf("A second favorite children's book"
" is 'Thoms ths tank"
" tied a b csad asdefw valva'");
```





使一段代码第一次执行时的行为与以后执行时不同

```C
generate_initializer(char *string)
{
	static char separator = ' ';
	printf("%c %s \n", separator, string);
	separar = ',';
}
```

- 第一次执行时，首先打印一个空格，然后打印一个初始化字符
- 后续的初始化字符前面加上一个逗号



- 函数前加`static`，只能当前函数使用
- 函数前加`extern`或者不加表示  全局可见



### 2.3 误做之过

#### 2.3.1 骆驼背上的重载

**C语言中的符号重载**

|  符号  | 意义                                                         |
| :----: | :----------------------------------------------------------- |
| static | 在函数内部，表示该变量的值在各个调用间一直保持延续性在函数这一级，<br>表示该函数只对本文件可见 |
| extern | 用于函数定义，表示全局可见<br>用于变量，表示在其他地方定义   |
|  void  | 作为函数的返回类型，表示不返回任何值<br>在指针声明中，表示通用指针的类型<br>位于参数列表中，表示没有参数 |
|   *    | 乘法运算符<br>用于指针，间接引语<br>在声明中，表示指针       |
|   &    | 位的AND操作符<br>取地址操作符                                |
|   =    | 赋值符                                                       |
|   ==   | 比较运算符                                                   |
|   <=   | 小于等于运算符                                               |
|  <<=   | 左移复合赋值运算符                                           |
|   <    | 小于运算符<br>`#include` 指令的左界定符                      |
|   ()   | 在函数定义中，包围形式参数列表<br>调用一个函数<br>改变表达式的运算次序<br>将值转换为其他类型<br>定义带参数的宏<br>包围`sizeof`操作符的操作数 |



```C
p = N * sizeof * q;
```

- 这里是一个乘号还是两个？**一个**。因为`sizeof`操作符吧指针q指向的东西(*q)作为操作数，它返回q所指向对象的类型的字节数，便于malloc函数分配内存。
- 当`sizeof`的操作数是一个类型的时候，两边必须加上括号



#### 2.3.2 “有些运算符的优先级是错误的”

**C语言运算符优先级存在的问题**

| 优先级问题                                           | 表达式              | 人们可能误以为的结果                             | 实际结果                                                 |
| ---------------------------------------------------- | ------------------- | ------------------------------------------------ | -------------------------------------------------------- |
| `.`的优先级高于`*`。<br>`->`**操作符用于消除该问题** | `*p.f`              | p所指对象的字段f<br>`(*p).f`                     | 对p取f偏移，作为指针，<br>然后进行解引用操作<br>`*(p.f)` |
| `[]`高于`*`                                          | `int *ap[]`         | ap是个指向int数组的指针<br>`int (*ap)[]`         | ap是个元素为int指针的数组<br>`int *(ap)`                 |
| 函数`()`高于`*`                                      | `int *fp()`         | fp是个函数指针，所指函数返回int<br>`int (*fp)()` | fp是个函数，返回`int *`<br>`int *(fp())`                 |
| `==`和`!=`高于位操作符                               | `(val & mask != 0)` | `(val & mask) != 0`                              | `val & (mask != 0)`                                      |
| `==`和`!=`高于赋值符                                 | `c=getchar != EOF`  | `(c=getchar) != EOF`                             | `c = (getchar != EOF)`                                   |
| 算数运算高于移位运算符                               | `msb << 4 + lsb`    | `(msb << 4) + lsb`                               | `msb << (4 + lsb)`                                       |
| 逗号运算符在所有<br>运算符中优先级最低               | `i = 1, 2`          | `i = (1, 2)`                                     | `(i = 1), 2`                                             |



```C
x = f(x) + g(x) * h();
```

- g()和h()的返回值线组成一个块，执行惩罚运算每当那时g()和h()的调用可能以任意顺序出现
- f()可能在乘法之前也可能乘法之后调用，也可鞥在g()和h()之间调用
- 唯一确定的是，乘法会在加法之前执行



**一条建议：乘除优先级高于加减，其余的运算都加上括号**



```C
int a, b = 1, c = 2;
```

- 所有的赋值符都具有右结合性，表达式中最右边的操作数最先执行，然后从右到左依次执行，c先赋值给b，然后b赋值给a，最终a的值是2
- 具有左结合性的操作符(位操作符`&`和`|`)则是从左至右依次执行的
- 结合性只用于表达式中出现两个以上相同优先级的操作符的情况，用于消除歧义



强烈建议使用`fgets()`取代`gets()`

```C
if(fgets(line, sizeof(line), stdin) == NULL)
    exit(1);
```



> C 库函数 **char \*fgets(char \*str, int n, FILE \*stream)** 从指定的流 stream 读取一行，并把它存储在 **str** 所指向的字符串内。当读取 **(n-1)** 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。
>
> `char *fgets(char *str, int n, FILE *stream)`
>
> - **str** -- 这是指向一个字符数组的指针，该数组存储了要读取的字符串。
> - **n** -- 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。
> - **stream** -- 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。
>
> 如果成功，该函数返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。
>
> 如果发生错误，返回一个空指针。
>
> ```C
> #include <stdio.h>
> 
> int main()
> {
>    FILE *fp;
>    char str[60];
> 
>    /* 打开用于读取的文件 */
>    fp = fopen("file.txt" , "r");
>    if(fp == NULL) {
>       perror("打开文件时发生错误");
>       return(-1);
>    }
>    if( fgets (str, 60, fp)!=NULL ) {
>       /* 向标准输出 stdout 写入内容 */
>       puts(str);
>    }
>    fclose(fp);
>    
>    return(0);
> }
> ```
>
> 假设我们有一个文本文件 **file.txt**，它的内容如下。文件将作为实例中的输入：
>
> ```
> We are in 2014
> ```
>
> 让我们编译并运行上面的程序，这将产生以下结果：
>
> ```
> We are in 2014
> ```
>
> 



### 2.4 少做之过

```c
z = y+++x;
```

- ANSIC规定了一种最大一口策略：如果下一个标记有超过一种的解释方案，编译器将选取能组成最长字符序列的方案
- 上边式子被解释为`z = y++ + x`;
- 但是还能出问题，`z=y+++++x;`，按前面策略会被解释为`z = y++ ++ + x`，报错，应该被解释为`z = y++ + ++x`;

```C
ratio = *x/*y
```

- 报错，`/`与`*`之间没有空格，被编译器理解为注释部分



在C语言中，自动变量在堆栈中分配内存，当包含自动变量的函数或代码块退出时，他们所占用的内存便会被回收

解决方法

- 返回一个指向字符串常量的指针
- 使用全局声明的数组
- 使用静态数组
- 显示的分配一些内存



