### **1. 操作符**



#### **1.1 算数操作符**

```C
+  -   *  /   %
```

除了%操作符，其余几个操作符都级可以浮点类型尤适用于整数类型



#### **1.2 移位操作符**

- 左移`<<`， 右移`>>`
  - 左移：最左边的几位被丢弃，右边空出来的几位由0补齐
  - 右移：
    - 逻辑移位：左边移入的位用0填充
    - 算数移位：左边移入的位由原先该值的符号位决定，符号位为1则移入的位均为1，符号位为0，则移入的位均为0。这样可以奥正原数的正负形式不变。例如`10010110`右移两位，逻辑移位的结果是`00100101`，算数移位的结果是`11100101`
    - 算数左移和逻辑左移是相同的
- 两个操作数必须都是`整型`类型
- `无符号执行的所有移位都是逻辑移位`，有符号采用逻辑移位还是算数移位取决于编译器

计数值中为1的个数

```C
int cont_one_bits(unsigned value) {    
    int ones;        
    for(ones=0; value!=0; value=value>>1) {        
        if(value%2!=0)            
            ones++;    
    }    
    return ones; 
}
```



#### **1.3 位操作符**

- AND   `&`
- OR     `|`
- XOR   `^`
- 要求操作数为整数类型

```C
// 将指定位置置1 
value = value | 1<<bit_number; 

// 将指定位置清0 
value = value & ~(1<<bit_number);
```



#### **1.4 赋值**

- 是表达式的一种，只要是允许出现表达式的地方都允许进行赋值
- 结合性：**从右到左**

```C
// 如下语句，认为a和x被赋予相同值的说法是不正确的 
a=x=y+3; 

// 如果x是一个字符变量，那么y+3的值就会被截去一段 
// 以便容纳与字符类型的变量中，
```

```C
char ch; 
... 
while((ch=getchar())!=EOF)
    ... 
// EOF所需位数比字符型的多，getchar的返回值先存储于ch中导致其被截短
```



- 复合赋值符 `+=`，`-=`，`*=`，`/=`，`%=`，`<<=`，`>>=`，`&=`，`^=`，`|=`
- 目的是为了提高效率

```C
// 将指定位置置1 
value |= 1<<bit_number; 

// 将指定位置清0 
value &= ~(1<<bit_number);
```

```C
int cont_one_bits(unsigned value) {    
    int ones;        
    for(ones=0; value!=0; value=value>>1) {        
        if(value&1!=0)            
            ones+=1;    
    }    
    return ones; 
}
```



#### **1.5 单目操作符**

- `!` 逻辑反
- `~` 求补操作
- `-` 产生操作数的负值
- `+` 操作数的值
- `&` 产生操作数的地址
- `*` 间接访问操作符，用于访问指针所指向的值
- `sizeof` 判断操作数的类型的长度  

```C
sizeof(int)	//返回整型变量的字节数 
sizeof x  	//返回变量x所占的字节数
```

sizeof的操作数是数组名时，返回数组的长度，以字节为单位。

**判断表达式的长度并不需要对表达式进行求值sizeof(a=b+1)并没有向a赋任何值**

- (类型) 被称为**强制类型转换**
- **++和**--要求操作符必须是一个左值，前缀和后缀形式的增值操作符都赋值一份变量的拷贝



```C
++a = 10;
```

- 报错，++a的结果是a值的拷贝，并不是变量本身，无法像一个值进行赋值



#### **1.6 关系型操作符**

- `>`   `>=`   `<`   `<=`   `!=`   `==`
- 这些操作符产生的结果都是一个`整型值`而不是布尔值

#### **1.7 逻辑操作符**

- `&&` 和 `||`
- 先对做操作数进行求值，为真，然后对有操作符求值，称为**短路求值**

#### **1.8 条件操作符**

`expr1 ? expr2 : expr3;`

#### **1.9 逗号操作符**

`expr0,expr1,...,exprN`

逗号操作符将两个或多个表达式分隔开来。这些表达式自左向右逐个进行求值，**整个逗号表达式的值就是最后那个表达式的值**

```C
if(b+1, c/2, d>0) 
// 若d>0，表达式为真
```



#### **1.10 下标调用，函数调用和结构成员**

```C
arrar[下标]  
    等价于 
*(array+下标)
```

**`.`和`->`操作符**用于访问一个结构的成员



### **2. 布尔值**

- **零是假，任何非零值皆为真**
- **不要使用简写的方法测试变量是零还是非零，因为这类形式错误的按时该变量在本质上是布尔的**
- 如果一个变量包含了一个任意的整型值，应当显式地对它进行测试`if(value != 0) ...`



### **3. 左值和右值**

- 左值就是可以出现在赋值符号左边的东西，右值就是可以出现在赋值符号右边的东西
- a=b+25； 左值标识了一个存储结果值的地点a，右值只是指定了一个值b+25
- 字面值常量也都不是左值



### **4. 表达式求值**

#### **4.1  隐式类型转换**

**整型提升：C的整型算数运算总是至少以缺省整型类型的精度来进行的。为了获得这个精度，表达式中的字符型和短整型操作数在使用之前被转换为普通类型，称为整型提升**

```C
char a, b, c;
...
a= b + c;
```

- b和c都被提升为普通整型，然后执行加法运算，加法运算的结果将被截短，然后再存储于a中





#### **4.2 算数转换**

```C
// 寻常算数转换 
long double 
double 
float 
usingned long int  
long int 
unsigned int 
int
```

如果某个操作数的类型在上面的这个列表中排名比较低，那么他首先将转换为另外一个操作数的类型然后执行操作



```c
int a = 5000;
int b = 25;
long c = a * b;
```

`a*b`是以整型进行计算，在32位上没问题，但是16位整数的机器上，乘法运算会产生溢出，这样C会被初始化为错误的值

解决方案：`long c = (long)a * b`





#### **4.3 操作符的属性**

复杂表达式的求值顺序由三个因素决定

- 操作符的优先级
- 操作符的结合性
- 操作符是否控制执行

**操作符的优先级**

|     **操作符**      | **结合性** | **操作符** | **结合性** |
| :-----------------: | :--------: | :--------: | :--------: |
|       **()**        |  **L-R**   |   **>=**   |  **L-R**   |
|       **[]**        |  **L-R**   |   **<**    |  **L-R**   |
| **.(访问结构成员)** |  **L-R**   |   **<=**   |  **L-R**   |
|       **->**        |  **L-R**   |   **==**   |  **L-R**   |
|       **++**        |  **L-R**   |   **!=**   |  **L-R**   |
|       **--**        |  **L-R**   |   **&**    |  **L-R**   |
|        **!**        |  **R-L**   |   **^**    |  **L-R**   |
|        **~**        |  **R-L**   |   **\|**   |  **L-R**   |
|  **+(单目，正值)**  |  **R-L**   |   **&&**   |  **L-R**   |
|  **-(单目，负值)**  |  **R-L**   |  **\|\|**  |  **L-R**   |
|       **++**        |  **R-L**   |   **?:**   |  **N/A**   |
|       **--**        |  **R-L**   |   **=**    |  **R-L**   |
|   ***(间接访问)**   |  **R-L**   |   **+=**   |  **R-L**   |
|    **&(取地址)**    |  **R-L**   |   **-=**   |  **R-L**   |
|    **sizeof()**     |  **R-L**   |   ***=**   |  **R-L**   |
|     **(类型)**      |  **R-L**   |   **/=**   |  **R-L**   |
|        *****        |  **L-R**   |   **%=**   |  **R-L**   |
|        **/**        |  **L-R**   |  **<<=**   |  **R-L**   |
|        **%**        |  **L-R**   |  **>>=**   |  **R-L**   |
|        **+**        |  **L-R**   |   **&=**   |  **R-L**   |
|        **-**        |  **L-R**   |   **^=**   |  **R-L**   |
|       **<<**        |  **L-R**   |  **\|=**   |  **R-L**   |
|       **>>**        |  **L-R**   |   **,**    |  **R-L**   |
|        **>**        |  **L-R**   |            |            |



- 两个相邻操作符的执行顺序由他们的优先级决定，如果他们的优先级相同，他们的执行顺序由他们的结合性决定。
- 也就是，表达式中操作符的优先级只决定表达式各个组成部分在求值过程中如何进行聚组



```C
f() + g() + h()
```

尽管左边的加法运算必须在右边的加法运算之前执行，但是对于各个函数的调用顺序没有规则限制，如果执行一些I/O任务或者修改全局变量，那么函数调用的顺序会产生不同的结果。应当使用如下方式：

```C
temp = f();
temp += g();
temp += h();
```



### **5. 注意**

- 有符号值的右移操作是不可移植的
- 移位操作的位数不可以是负值
- 连续赋值中各个变量的长度不一的问题，会导致数据被截短的问题

