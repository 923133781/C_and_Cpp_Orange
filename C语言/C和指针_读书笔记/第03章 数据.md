# 第3章 数据

### **1. 整型**

包括：字符，短整型，长整型，整型

都分为有符号和无符号两个版本

**长整型至少应该和整型一样长，而整型至少应该和短整型一样长**

**变量的最小范围**

| **类型**           | **最小范围**           |
| ------------------ | ---------------------- |
| char               | 0~127                  |
| signed char        | -127~127               |
| unsigned char      | 0~255                  |
| short int          | -32767 ~ 32767         |
| unsigned short int | 0~65535                |
| int                | -32767~32767           |
| unsigned int       | 0~65535                |
| long int           | -2147483647~2147483647 |
| unsigned long in   | 0~4294967295           |

short int至少16位

long int 至少32位

**头文件limits.h中有变量的限制范围**

|        |  signed   |  signed   | unsigned  |
| :----: | :-------: | :-------: | :-------: |
|  类型  |  最小值   |  最大值   |  最大值   |
|  字符  | SCHAR_MIN | SCHAR_MAX | UCHAR_MAX |
| 短整型 | SHRT_MIN  | SHRT_MAX  | USHRT_MAX |
|  整型  |  INT_MIN  |  INT_MAX  | UINT_MAX  |
| 长整型 | LONG_MIN  | LONG_MIN  | ULONG_MAX |

char的本质是最小整型值，为了让其容纳字符型值

**为了便于移植，最好在定义char前加入signed或者unsigned;**

**字面值常量：**制定了自身值切不允许改变

在某些字面值后加入后缀改变缺省的规则

- 在整数字面值后加入L或者l，可以使这个整数被解释为long整数型
- 字符u或者U用于将数值指定为unsigned整型值
- 整数前加入0表示八进制数
- 整数前加入0x表示十六进制
- 如果一个多字节字符常量前面有一个L，那么他就是**宽字符常量**，如  L'x'

### **2. 枚举**

就是指它的值为符号常量而不是字面值的类型

```C
// 声明类型 
enum Jar {CUP, PINT, QUART, HALF_GALLON, GALLON}; 

// 声明该类型变量 
enum Jar milk_juh, gas_can; 

//这中变量实际上以整型的方式存储，A是0， B是1，... 
enum {A, B, C, D} 

// 如果某个符号未显示的指定一个值，那么它的值就比前一个值大1
```



### **3. 浮点类型**

包括 float, double, long double

**所有浮点类型至少容纳从10^-37 ~ 10^37**

**浮点数字面值缺省都是double类型的，出后后面跟了L或者l表示是long double，跟一个F或f表示是一个float类型**



`float.h`头文件中定义了名字`FLT_MAX`、`DBL_MAX`和`LDBL_MAX`分别表示`float`、`double`和`long double`的最大值，`FLT_MIN`、`DBL_MIN`和`LDBL_MIN`分别表示`float`、`double`和`long double`的最小值



###  **4. 声明指针**

```C
//最好使用如下的形式 
int *a; 

//如下的形式不够清楚 
int* a, b, c; 
int const *a; 

// 指向整形常量的指针，可以修改指针的值但是不能修改其指向的值 
int *const b; 
// b为指向整形的常量指针，可修改指针指向的值，但是不能修改指针的值
```

字符串常量：一串以NUL字节结尾的零个或者多个字符

### **5. 应该使用typedef而不是#define来创建新的类型名，后者无法正确的处理指针类型**

```C
#define A char * 
A a, b; 
// 正确声明了a, 但是b确是一个字符
```

```C
int const *cpi;	
// 一个指向整型常量的指针，可以修改指针的值，但是不能修改所指向的值

int * const cpi;
// 一个指向整型的常量指针，此时指针是常量，值无法修改，但是可以修改其指向的整型的值
```





### **6. static可将连接属性变为internal，一个标识符指定external属性可以访问其他任何位置定义的该实体**

### **7. 存储类型**

- 代码块之外声明的变量总是存储于静态内存中，称为静态变量，无法为他们指定其他存储类型。在程序运行之前创建，执行期间始终存在，始终保持原先的值除非给它赋值一个不一样的值或者程序的结束。
- 代码块内部声明的变量存储于堆栈中，执行到代码块时创建，执行流离开代码块时销毁
- 代码块内部声明变量前加static后，从自动变量变为静态变量。在程序执行中一直存在，但是不修改变量的作用域
- 函数形参不能声明为静态变量，实参总是在堆栈中传递给函数，用于支持递归
- register用于自动变量的声明，提示它们应该存储于机器的硬件寄存器而不是内存中。称为寄存器变量。效率更高，但是编译器自己决定将哪几个变量设置为寄存器变量。
- 静态变量若不显示初始化，默认初始化为0
- 自动变量初始化需要更多开销，因为程序链接时无法判断自动变量的存储位置

### **8. static**

- 用于函数定义时，或用于代码块之外的变量声明时，用于修改标识符的链接属性，从external变为internal，但是标识符的存储类型和作用域未改变。这种方式声明的函数或者变量只能在声明他们的源文件中访问
- 用于代码内部声明变量的时候，用于修改变量的存储类型，将自动变量修改为静态变量，链接属性和作用域不修改。用这种方是生命的变量在程序执行之前创建，执行期间一直存在，代码块执行完毕后销毁

### **9. 具有external链接属性的实体总是具有静态存储类型**

### **10. 作用域**

- **文件作用域：**任何代码块之外的声明的标识符都具有文件作用域，从声明之处到所在源文件的末尾都是可以访问的
- **函数作用域**：一个函数中的所有语句的标签都必须唯一 
- **代码块作用域：**位于一对花括号之间的所有语句称为一个代码块，任何在代码块开始位置声明的标识符都具有代码块作用域。**避免在嵌套的代码块中出现相同的变量名。**
- **原型作用域：**只是适用于在函数原型中声明的参数名。使用函数时形参名字不必与声明函数所用的参数名字相同



### **11. 链接属性**

一共有三种

- external
- internal
- none



```C
typedef char *a;
int b;
int c( int d ){
    int e;
    int f (int g);
    ...
}
```

- b，c，f的链接属性为external，其余的为none
- 如果另一个源文件也包含了标识符b的类似声明，并调用了c，他们实际上访问的是这个源文件所定义的实体
- f的链接属性属于external是因为他是个函数名，在当前文件调用f函数，实际上将其连接到其他源文件所定义的函数



关键字`externa`和`static`用于在声明中修改标识符的链接属性

- 若某个声明具有external属性，在前面加入static关键字可将链接属性变为internal
- 将函数或者变量声明为static可以防止它被其他文件使用，支队缺省链接属性为external的声明才有改变链接属性的效果
- 当`extern`关键字用于源文件中一个标识符的第1次声明时，它指定该标识符具有exteranl属性，但是它用于该标识符的第2次或以后的声明时，它并不会更改由第1次声明所指定的链接属性

```C
static int i;
int func(){
    int j;
    extern int k;
    extern int i;
    ...
}
// 4行的声明并不修改1行所指定的变量i的属性
```



**作用域、链接属性和存储类型总结**

| 变量类型 |   声明的位置   | 是否存在于堆栈 |       作用域       |                    若声明为static                    |
| :------: | :------------: | :------------: | :----------------: | :--------------------------------------------------: |
|   全局   | 所有代码块之外 |       否       | 从声明处到文件末尾 |                 不允许其他源文件访问                 |
|   局部   |  代码块起始处  |       是       |     整个代码块     | 变量不存储于堆栈中，<br>值在程序整个执行期间一直保持 |
|   形参   |    函数头部    |       是       |      整个函数      |                        不允许                        |





### **12. 总结**

- 为了保证可移植性，把字符的值限制在有符号和无符号字符范围的交集中，或者不要在兹附上执行算术运算
- 不要将整型值和枚举值混合使用
- 不要依赖隐式声明
- 使用名字常量而不是字面值常量
- 不要再嵌套的代码块之间使用相同的变量名
- 除了实体的具体定义位置之外，在它的其它位置都使用`extern`关键字