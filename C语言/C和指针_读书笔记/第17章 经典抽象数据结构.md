**1. 堆栈接口**

/* 堆栈的接口 */ #define STACK_TYPE int void push(STACK_TYPE value); void pop(void); STACK_TYPE top(void); int is_empty(void); int is_full(void);

**1.1 静态数组编写**

\#include "stack.h" #include <assert.h> #define STACK_SIZE 100 static STACK_TYPE stack[STACK_SIZE]; static int top_element = -1; void push(STACK_TYPE value) {    assert(!is_full());    top_element += 1;    stack[top_element]=value; } void pop(void) {    assert(!is_empty());    top_elemrnt -= 1; } STACK_TYPE top(void) {    assert(!is_empty());    return stack[top_element]; } int is_empty(void) {    return top_element==-1; } int is_full(void) {    return top_element == STACK_SIZE - 1; }

STACK_TYPE pop(void) {    STACK_TYPE temp;    assert(!is_empty());    tm=stack[top_element];    top_element -= 1;    return temp; }

**1.2 动态数组编写**

\#include "stack.h" #include <stdio.h> #include <stdlib.h> #include <malloc.h> #include <assert.h> static STACK_TYPE *stack; static size_t stack_size; static int top_element=-1; void create_stack(size_t size) {    assert(stzck_size==0);    stack_size=size;    stack=malloc(stack_size*sizeof(STACK_TYPE));    assert(stack!=NULL); } void destroy_stack(void) {    assert(stack_size>0);    stack_size=0;    free(stack);    stack=NULL; } void push(STACK_TYPE value) {    assert(!is_full());    top_element += 1;    stack[top_element]=value; } void pop(void) {    assert(!is_empty());    top_element -= 1; } STACK_TYPE top(void) {    assert(!is_empty());    return stack[top_element]; } int is_empty(void) {    assert(stack_size>0);    return top_element == -1; } int is_full(void) {    assert(stack_size>0);    return top_element==stack_size-1; }

**1.3 链式堆栈**